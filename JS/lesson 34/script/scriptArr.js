"use strict";
// использование строгого режима для обработки данных


let number = 1;
// данные которые указываются без скобок = число
let text = "Ismar";
// данные которые заключены в скобки называются строки - "string"
console.log(number);
console.log(text);
console.log(10*5);
console.log(10*"Ismar"); 
//NaN - это означает не правильное использование синтаксиса
// то есть нельзя умножать(*) , делить(-) и отнимать (-) число и текст 
 //результат будет NaN

console.log(text+1);
// текст + цифра = это будет означать ОПЕРАЦИЮ склеивания
// + это операция склеивания и сложения



console.log(number+1); // получим 2

//TRUE=ИСТИНА
//FALSE=ЛОЖЬ

let number2 = true;
console.log(number2);

// console.log(unknown);  // ошибка - is not defined = не определено

//создание объекта начинается с фигурных скобок
let obj = {
    name:"Ismar",
    // name это название первого объекта
    // :    это разделение между объектом и его значением
    //""    внутри ковычек указывается значение объекта 
    // конец строки заканчивается на ,
    age:26,
    location:"Kyrgyzstan"
    
};

// Первый вариант получения данных из объекта

// console.log - это команда для вывода данных на экран
    // obj -это переменная
        // . это операция обращения к объекту
            // name это название объекта

console.log("Name:" + obj.name + " Age:"+ obj.age);

// Второй вариант получения данных из объекта

// obj -это переменная
    // [] -это указание позиции и уточнения объекта
        // "" нужны для определния объекта
            // name это название объекта

console.log(obj["name"]);

// Массивы
// Массив создается с помощью квадратных скобок[]
// В массивах используются сразу значения
// для получения значения необходимо использовать порядковый номер

        //   0           1        2
let arr = ["яблоко", "iphone", "pen"];

// console.log[arr.яблоко]; //undefined , не понятно-не определено

console.log(arr[0]); //яблоко


// ==========ОБЪЕКТЫ================

//Объекты – это ассоциативные массивы с рядом дополнительных возможностей.
// Они хранят свойства (пары ключ-значение), где:
// Ключи свойств должны быть строками или символами (обычно строками).
// Значения могут быть любого типа.

// ------Чтобы получить доступ к свойству, мы можем использовать:
// Запись через точку: obj.property.
// Квадратные скобки obj["property"]. 
// Квадратные скобки позволяют взять ключ из переменной, 
//например, obj[varWithKey].

// -----Дополнительные операторы:
// Удаление свойства: delete obj.prop.
// Проверка существования свойства: "key" in obj.
// Перебор свойств объекта: цикл for for (let key in obj).



//===========МАССИВЫ===========

// Массив – это особый тип объекта, предназначенный 
//для работы с упорядоченным набором элементов.

// Объявление:
// квадратные скобки (обычно)
// let arr = [item1, item2...];
// new Array (очень редко)
// let arr = new Array(item1, item2...);

// Вызов new Array(number) создаёт массив 
//с заданной длиной, но без элементов.

// Свойство length отражает длину массива или, 
//если точнее, его последний цифровой индекс плюс один. 
//Длина корректируется автоматически методами массива.
// Если мы уменьшаем length вручную, массив укорачивается.

// Мы можем использовать массив как двустороннюю очередь, 
//используя следующие операции:

// push(...items)добавляет items в конец массива.
// pop() удаляет элемент в конце массива и возвращает его.
// shift() удаляет элемент в начале массива и возвращает его.
// unshift(...items) добавляет items в начало массива.

// Чтобы пройтись по элементам массива:
// for (let i=0; i<arr.length; i++) – работает быстрее всего,
// совместим со старыми браузерами.
// for (let item of arr) – современный синтаксис только для 
//значений элементов (к индексам нет доступа).
// for (let i in arr) – никогда не используйте для массивов!


//  ---------------Массивы и псевдомассивы

const arr2 = [1,2,3,4,5];
    //Индексы 0,1,2,3,4

    // _______________Метод pop()- получение последнего индекса

    console.log(arr2.pop());  // 5

    console.log(arr2); // с выводом элемента удалется сам элемент из массива
                       //arr2 = [1,2,3,4,];

    // _______________Метод shift() получение значения с начала списка
    
    const arr3 = [1,2,3,4,5];
    console.log(arr3.shift());  // 1

    console.log(arr3);  // с выводом элемента удалется сам элемент из массива
                        //   arr2 = [2,3,4,5];

    // _______________Метод push() -добавляет элемент в конец массива
    const arr4 = [1,2,3,4,5];
    console.log(arr4.push(10)); 
    console.log(arr4);       // arr2 = [1,2,3,4,5,10];


    // _______________Метод unshift() -добавляет элемент в начало массива
    const arr5 = [1,2,3,4,5];
    console.log(arr5.unshift(15)); 
    console.log(arr5);             // arr2 = [15,1,2,3,4,5];
    // при данном методе значение индексов элементов сдвигается (сдвиг индексов)


    const arr6 = [1,2,3,4,5];
    delete arr6[0];
    console.log(arr6[0]); //Вроде бы, элемент и был удалён, но при проверке 
                          //оказывается, что массив всё ещё имеет 5 элемента
    console.log(arr6);    // 1: 2
                          // 2: 3
                          // 3: 4
                          // 4: 5
                          // length: 5
                          // или  [ <1 empty item>, 2, 3, 4, 5 ] в терминале

    // Это нормально, потому что всё, что делает delete obj.key – это удаляет 
    // значение с данным ключом key. Это нормально для объектов, но для 
    // массивов мы обычно хотим, чтобы оставшиеся элементы сдвинулись и заняли 
    // освободившееся место. Мы ждём, что массив станет короче.



    // _____________Метод splice -этот метод позволяет найти из нашего массива 
    // и удалить какойто элемент

    // Метод arr.splice(str) – это универсальный «швейцарский нож» для работы 
    // с массивами. Умеет всё: добавлять, удалять и заменять элементы.

    // Его синтаксис:
    
    // arr.splice(index[, deleteCount, elem1, ..., elemN])
    // Он начинает с позиции index, удаляет deleteCount элементов и вставляет 
    // elem1, ..., elemN на их место. Возвращает массив из удалённых элементов.
    
    // Этот метод проще всего понять, рассмотрев примеры.
    
    // Начнём с удаления:
    // let arr = ["Я", "изучаю", "JavaScript"];
    // arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент
    
    // alert( arr ); // осталось ["Я", "JavaScript"]
    // Легко, правда? Начиная с позиции 1, он убрал 1 элемент.
    
    // В следующем примере мы удалим 3 элемента и заменим их двумя другими.
    
    // let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
    // удалить 3 первых элемента и заменить их другими
    // arr.splice(0, 3, "Давай", "танцевать");
    // alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]

    // Здесь видно, что splice возвращает массив из удалённых элементов:
    // let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
    // удалить 2 первых элемента
    // let removed = arr.splice(0, 2);
    
    // alert( removed ); // "Я", "изучаю" <-- массив из удалённых элементов
    // Метод splice также может вставлять элементы без удаления, для этого 
    // достаточно установить deleteCount в 0:
    
    // let arr = ["Я", "изучаю", "JavaScript"];
    
    // с позиции 2
    // удалить 0 элементов
    // вставить "сложный", "язык"
    // arr.splice(2, 0, "сложный", "язык");
    
    // alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript

    // _____________________Метод slice

    //Его синтаксис:

// arr.slice([start], [end])
// Он возвращает новый массив, в который копирует элементы, начиная с 
// индекса start и до end (не включая end). Оба индекса start и end могут 
// быть отрицательными. В таком случае отсчёт будет осуществляться с конца 
// массива.

// Это похоже на строковый метод str.slice, но вместо подстрок возвращает 
// подмассивы.

//Например:

//let arr = ["t", "e", "s", "t"];

//alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)

//alert( arr.slice(-2) ); // s,t (копирует с -2 до конца)

// Можно вызвать slice и вообще без аргументов: 
// arr.slice() создаёт копию массива arr. Это часто используют, 
// чтобы создать копию массива для дальнейших преобразований, 
// которые не должны менять исходный массив

// _____________________Метод concat

// Метод arr.concat создаёт новый массив, в который копирует данные
// из других массивов и дополнительные значения.

// Его синтаксис:

// arr.concat(arg1, arg2...)
// Он принимает любое количество аргументов, которые могут быть как 
// массивами, так и простыми значениями.

// В результате мы получаем новый массив, включающий в себя элементы 
// из arr, а также arg1, arg2 и так далее…

// Если аргумент argN – массив, то все его элементы копируются. 
// Иначе скопируется сам аргумент.

// Например:

// let arr = [1, 2];

// создать массив из: arr и [3,4]
// alert( arr.concat([3, 4]) ); // 1,2,3,4

// создать массив из: arr и [3,4] и [5,6]
// alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

// создать массив из: arr и [3,4], потом добавить значения 5 и 6
// alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
// Обычно он просто копирует элементы из массивов. Другие объекты, 
// даже если они выглядят как массивы, добавляются как есть:

// let arr = [1, 2];

// let arrayLike = {
//   0: "что-то",
//   length: 1
// };

//alert( arr.concat(arrayLike) ); // 1,2,[object Object]

// …Но если объект имеет специальное свойство Symbol.isConcatSpreadable,
//  то он обрабатывается concat как массив: вместо него добавляются его
//  числовые свойства.

//Для корректной обработки в объекте должны быть числовые свойства и length:

//let arr = [1, 2];

//let arrayLike = {
//   0: "что-то",
//   1: "ещё",
//   [Symbol.isConcatSpreadable]: true,
//   length: 2
// };

//alert( arr.concat(arrayLike) ); // 1,2,что-то,ещё


// _____________________Метод forEach
// Метод arr.forEach позволяет запускать функцию для каждого 
// элемента массива (Перебор: forEach)

// Его синтаксис:

//arr.forEach(function(item, index, array) {
  // ... делать что-то с item
// });
//Например, этот код выведет на экран каждый элемент массива:

// Вызов alert для каждого элемента
//["Bilbo", "Gandalf", "Nazgul"].forEach(alert);

//А этот вдобавок расскажет и о своей позиции в массиве:
// ["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
//   alert(`${item} имеет позицию ${index} в ${array}`);
// });
// Результат функции (если она вообще что-то возвращает) отбрасывается 
//и игнорируется


//Поиск в массиве
//Далее рассмотрим методы, которые помогут найти что-нибудь в массиве.


// _____________________Методы indexOf/lastIndexOf, includes

// Методы arr.indexOf, arr.lastIndexOf и arr.includes имеют одинаковый 
// синтаксис и делают по сути то же самое, что и их строковые аналоги, 
// но работают с элементами вместо символов:

// arr.indexOf(item, from) ищет item, начиная с индекса from, 
// и возвращает индекс, на котором был найден искомый элемент, 
// в противном случае -1.
//---------------
// const a = [9, 8, 7, 5]
// console.log(a.indexOf(7)) // 2 искать значение в массиве
// в скобки передается значение, а выводится результат индекс
// 
//---------------


//arr.lastIndexOf(item, from) – то же самое, но ищет справа налево.

// arr.includes(item, from) – ищет item, начиная с индекса from, и 
// возвращает только true, если поиск успешен или false

// Например:

// let arr = [1, 0, false];

// alert( arr.indexOf(0) ); // 1
// alert( arr.indexOf(false) ); // 2
// alert( arr.indexOf(null) ); // -1

// alert( arr.includes(1) ); // true

// Обратите внимание, что методы используют строгое сравнение ===. 
// Таким образом, если мы ищем false, он находит именно false, 
// а не ноль.

// Если мы хотим проверить наличие элемента, и нет необходимости знать 
// его точный индекс, тогда предпочтительным является arr.includes.

// Кроме того, очень незначительным отличием includes является то, что он 
// правильно обрабатывает NaN в отличие от indexOf/lastIndexOf:

// const arr = [NaN];
// alert( arr.indexOf(NaN) ); // -1 (должен быть 0, но === проверка 
//на равенство не работает для NaN)

// alert( arr.includes(NaN) );// true (верно)


// _____________________Методы find и findIndex

// Представьте, что у нас есть массив объектов. Как нам найти объект с 
// определённым условием?

// Здесь пригодится метод arr.find.

// Его синтаксис таков:

// let result = arr.find(function(item, index, array) {
  // если true - возвращается текущий элемент и перебор прерывается
  // если все итерации оказались ложными, возвращается undefined
// });
// Функция вызывается по очереди для каждого элемента массива:

// item – очередной элемент.
// index – его индекс.
// array – сам массив.
// Если функция возвращает true, поиск прерывается и возвращается item. 
// Если ничего не найдено, возвращается undefined.

// Например, у нас есть массив пользователей, каждый из которых имеет поля
//  id и name. Попробуем найти того, кто с id == 1:

// let users = [
//   {id: 1, name: "Вася"},
//   {id: 2, name: "Петя"},
//   {id: 3, name: "Маша"}
// ];

// let user = users.find(item => item.id == 1);

// alert(user.name); // Вася
// В реальной жизни массивы объектов – обычное дело, поэтому метод find крайне 
//полезен.

// Обратите внимание, что в данном примере мы передаём find функцию item =>
//item.id == 1, с одним аргументом. Это типично, дополнительные аргументы 
//этой функции используются редко.

// Метод arr.findIndex – по сути, то же самое, но возвращает индекс, на котором 
//был найден элемент, а не сам элемент, и -1, если ничего не найдено.

// _____________________Методы filter

// Метод find ищет один (первый попавшийся) элемент, на котором 
// функция-колбэк вернёт true.

// На тот случай, если найденных элементов может быть много, предусмотрен 
// метод arr.filter(fn).

// Синтаксис этого метода схож с find, но filter возвращает массив из всех 
// подходящих элементов:

// let results = arr.filter(function(item, index, array) {
  // если true - элемент добавляется к результату, и перебор продолжается
  // возвращается пустой массив в случае, если ничего не найдено
// });
// Например:

// let users = [
//   {id: 1, name: "Вася"},
//   {id: 2, name: "Петя"},
//   {id: 3, name: "Маша"}
// ];

// возвращает массив, состоящий из двух первых пользователей
//let someUsers = users.filter(item => item.id < 3);

//alert(someUsers.length); // 2


//Преобразование массива
//Перейдём к методам преобразования и упорядочения массива.

//_____________________Метод map 
// Метод arr.map является одним из наиболее полезных и часто 
// используемых.

// Он вызывает функцию для каждого элемента массива и возвращает 
// массив результатов выполнения этой функции.

// Синтаксис:

//let result = arr.map(function(item, index, array) {
  // возвращается новое значение вместо элемента
// });
// Например, здесь мы преобразуем каждый элемент в его длину:

// let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
// alert(lengths); // 5,7,6


//_____________________Метод sort(fn)
//Вызов arr.sort() сортирует массив на месте, меняя в нём порядок элементов.

// Он возвращает отсортированный массив, но обычно возвращаемое значение 
// игнорируется, так как изменяется сам arr.

// Например:

// let arr = [ 1, 2, 15 ];

// метод сортирует содержимое arr
//arr.sort();

//alert( arr );  // 1, 15, 2
//Не заметили ничего странного в этом примере?

//Порядок стал 1, 15, 2. Это неправильно! Но почему?

//По умолчанию элементы сортируются как строки.

// Буквально, элементы преобразуются в строки при сравнении. 
// Для строк применяется лексикографический порядок, и действительно выходит, 
// что "2" > "15".

// Чтобы использовать наш собственный порядок сортировки, нам нужно 
// предоставить функцию в качестве аргумента arr.sort().

// Функция должна для пары значений возвращать:

// function compare(a, b) {
//   if (a > b) return 1; // если первое значение больше второго
//   if (a == b) return 0; // если равны
//   if (a < b) return -1; // если первое значение меньше второго
// }
// Например, для сортировки чисел:

// function compareNumeric(a, b) {
//   if (a > b) return 1;
//   if (a == b) return 0;
//   if (a < b) return -1;
// }

// let arr = [ 1, 2, 15 ];

// arr.sort(compareNumeric);

// alert(arr);  // 1, 2, 15
// Теперь всё работает как надо.

// Давайте возьмём паузу и подумаем, что же происходит. Упомянутый 
// ранее массив arr может быть массивом чего угодно, верно? Он может 
// содержать числа, строки, объекты или что-то ещё. У нас есть набор 
// каких-то элементов. Чтобы отсортировать его, нам нужна функция, 
// определяющая порядок, которая знает, как сравнивать его элементы. 
// По умолчанию элементы сортируются как строки.

// Метод arr.sort(fn) реализует общий алгоритм сортировки. Нам не нужно 
// заботиться о том, как он работает внутри (в большинстве случаев это 
// оптимизированная быстрая сортировка). Она проходится по массиву, сравнивает 
// его элементы с помощью предоставленной функции и переупорядочивает их. Всё, 
// что остаётся нам, это предоставить fn, которая делает это сравнение.

// Кстати, если мы когда-нибудь захотим узнать, какие элементы сравниваются – 
// ничто не мешает нам вывести их на экран:

// [1, -2, 15, 2, 0, 8].sort(function(a, b) {
//   alert( a + " <> " + b );
// });
// В процессе работы алгоритм может сравнивать элемент с другими по 
// нескольку раз, но он старается сделать как можно меньше сравнений.

// !!!!!!!!  Функция сравнения может вернуть любое число
// На самом деле от функции сравнения требуется любое положительное число,
// чтобы сказать «больше», и отрицательное число, чтобы сказать «меньше».

// Это позволяет писать более короткие функции:

// let arr = [ 1, 2, 15 ];

// arr.sort(function(a, b) { return a - b; });

// alert(arr);  // 1, 2, 15

// !!!!!!!!!!Лучше использовать стрелочные функции
// Помните стрелочные функции? Можно использовать их здесь для того, чтобы 
// сортировка выглядела более аккуратной:

// arr.sort( (a, b) => a - b );
// Будет работать точно так же, как и более длинная версия выше.

// _____________________Метод reverse
// Метод arr.reverse меняет порядок элементов в arr на обратный.

// Например:

// let arr = [1, 2, 3, 4, 5];
// arr.reverse();

// alert( arr ); // 5,4,3,2,1
// Он также возвращает массив arr с изменённым порядком элементов.



//_____________________Метод split и join

// Ситуация из реальной жизни. Мы пишем приложение для обмена сообщениями, 
// и посетитель вводит имена тех, кому его отправить, через запятую: Вася, 
// Петя, Маша. Но нам-то гораздо удобнее работать с массивом имён, чем с 
// одной строкой. Как его получить?

// Метод str.split(delim) именно это и делает. Он разбивает строку на массив 
// по заданному разделителю delim.

// В примере ниже таким разделителем является строка из запятой и пробела.

// let names = 'Вася, Петя, Маша';

// let arr = names.split(', ');

// for (let name of arr) {
  //alert( `Сообщение получат: ${name}.` ); // Сообщение получат: Вася 
  //(и другие имена)
//}
// У метода split есть необязательный второй числовой аргумент – ограничение 
// на количество элементов в массиве. Если их больше, чем указано, то остаток 
// массива будет отброшен. На практике это редко используется:

// let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);

// alert(arr); // Вася, Петя
// Разбивка по буквам
// Вызов split(s) с пустым аргументом s разбил бы строку на массив букв:

// let str = "тест";

// alert( str.split('') ); // т,е,с,т
// Вызов arr.join(glue) делает в точности противоположное split. Он создаёт 
// строку из элементов arr, вставляя glue между ними.

// Например:

// let arr = ['Вася', 'Петя', 'Маша'];

//let str = arr.join(';'); // объединить массив в строку через ;

//alert( str ); // Вася;Петя;Маша

//_____________________Методы reduce/reduceRight

// Если нам нужно перебрать массив – мы можем использовать forEach, 
// for или for..of.

// Если нам нужно перебрать массив и вернуть данные для каждого 
// элемента – мы используем map.

// Методы arr.reduce и arr.reduceRight похожи на методы выше, но они немного 
// сложнее. Они используются для вычисления какого-нибудь единого значения на 
// основе всего массива.

// Синтаксис:

//let value = arr.reduce(function(previousValue, item, index, array) {
  // ...
//}, [initial]);
// Функция применяется по очереди ко всем элементам массива и «переносит» 
// свой результат на следующий вызов.

// Аргументы:

// previousValue – результат предыдущего вызова этой функции, равен initial при 
// первом вызове (если передан initial),
// item – очередной элемент массива,
// index – его индекс,
// array – сам массив.
// При вызове функции результат её вызова на предыдущем элементе массива 
// передаётся как первый аргумент.

// Звучит сложновато, но всё становится проще, если думать о первом аргументе
// как «аккумулирующем» результат предыдущих вызовов функции. По окончании он 
// становится результатом reduce.

// Этот метод проще всего понять на примере.

// Тут мы получим сумму всех элементов массива всего одной строкой:

// let arr = [1, 2, 3, 4, 5];

// let result = arr.reduce((sum, current) => sum + current, 0);

// alert(result); // 15
// Здесь мы использовали наиболее распространённый вариант reduce, 
// который использует только 2 аргумента.

// Давайте детальнее разберём, как он работает.

// При первом запуске sum равен initial (последний аргумент reduce), 
// то есть 0, а current – первый элемент массива, равный 1. Таким образом, 
// результат функции равен 1.
// При втором запуске sum = 1, и к нему мы добавляем второй элемент 
// массива (2).
// При третьем запуске sum = 3, к которому мы добавляем следующий элемент, 
// и так далее…

// Поток вычислений получается такой:
// В виде таблицы, где каждая строка –- вызов функции на очередном элементе
// массива:

//                sum	current	result
// первый вызов 	0	  1	      1
// второй вызов	    1	  2	      3
// третий вызов	    3	  3	      6
// четвёртый вызов	6	  4	      10
// пятый вызов	    10	  5	      15
// Здесь отчётливо видно, как результат предыдущего вызова передаётся в 
// первый аргумент следующего.

// Мы также можем опустить начальное значение:

// let arr = [1, 2, 3, 4, 5];

// убрано начальное значение (нет 0 в конце)
//let result = arr.reduce((sum, current) => sum + current);

// alert( result ); // 15
// Результат – точно такой же! Это потому, что при отсутствии initial в 
// качестве первого значения берётся первый элемент массива, а перебор стартует
// со второго.

// Таблица вычислений будет такая же за вычетом первой строки.

// Но такое использование требует крайней осторожности. Если массив пуст, то вызов 
// reduce без начального значения выдаст ошибку.

// Вот пример:

// let arr = [];

// Error: Reduce of empty array with no initial value
// если бы существовало начальное значение, reduce вернул бы его 
//для пустого массива.
// arr.reduce((sum, current) => sum + current);
// Поэтому рекомендуется всегда указывать начальное значение.

// Метод arr.reduceRight работает аналогично, но проходит по массиву
//справа налево.


//Array.isArray
//Массивы не образуют отдельный тип языка. Они основаны на объектах.

//Поэтому typeof не может отличить простой объект от массива:

// alert(typeof {}); // object
// alert(typeof []); // тоже object
//Но массивы используются настолько часто, что для этого придумали специальный 
// метод: Array.isArray(value). Он возвращает true, если value массив, и false, 
// если нет.

// alert(Array.isArray({})); // false

// alert(Array.isArray([])); // true
// Большинство методов поддерживают «thisArg»
// Почти все методы массива, которые вызывают функции – такие как find, 
// filter, map, за исключением метода sort, принимают необязательный параметр
// thisArg.

// Этот параметр не объяснялся выше, так как очень редко используется, 
// но для наиболее полного понимания темы мы обязаны его рассмотреть.

// Вот полный синтаксис этих методов:

// arr.find(func, thisArg);
// arr.filter(func, thisArg);
// arr.map(func, thisArg);
// ...
// thisArg - это необязательный последний аргумент
// Значение параметра thisArg становится this для func.

// Например, вот тут мы используем метод объекта army как фильтр, и thisArg 
// передаёт ему контекст:

// let army = {
//   minAge: 18,
//   maxAge: 27,
//   canJoin(user) {
//     return user.age >= this.minAge && user.age < this.maxAge;
//   }
// };

// let users = [
//   {age: 16},
//   {age: 20},
//   {age: 23},
//   {age: 30}
// ];

// найти пользователей, для которых army.canJoin возвращает true
//let soldiers = users.filter(army.canJoin, army);

// alert(soldiers.length); // 2
// alert(soldiers[0].age); // 20
// alert(soldiers[1].age); // 23
// Если бы мы в примере выше использовали просто users.filter(army.canJoin), 
// то вызов army.canJoin был бы в режиме отдельной функции, с this=undefined. 
// Это тут же привело бы к ошибке.

// Вызов users.filter(army.canJoin, army) можно заменить на 
// users.filter(user => army.canJoin(user)), который делает то же самое. 
// Последняя запись используется даже чаще, так как функция-стрелка
//более наглядна.

// ИТОГО
// Шпаргалка по методам массива:

// Для добавления/удаления элементов:

// push (...items) – добавляет элементы в конец,
// pop() – извлекает элемент с конца,
// shift() – извлекает элемент с начала,
// unshift(...items) – добавляет элементы в начало.
// splice(pos, deleteCount, ...items) – начиная с индекса pos, удаляет 
// deleteCount элементов и вставляет items.
// slice(start, end) – создаёт новый массив, копируя в него элементы с 
// позиции start до end (не включая end).
// concat(...items) – возвращает новый массив: копирует все члены 
// текущего массива и добавляет к нему items. Если какой-то из items 
// является массивом, тогда берутся его элементы.
// Для поиска среди элементов:

// indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, 
// и возвращает его индекс или -1, если ничего не найдено.
// includes(value) – возвращает true, если в массиве имеется элемент value, 
// в противном случае false.
// find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все 
// значения, при прохождении которых через функцию возвращается true.
// findIndex похож на find, но возвращает индекс вместо значения.
// Для перебора элементов:

// forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.
// Для преобразования массива:

// map(func) – создаёт новый массив из результатов вызова func для каждого 
// элемента.
// sort(func) – сортирует массив «на месте», а потом возвращает его.
// reverse() – «на месте» меняет порядок следования элементов на 
// противоположный и возвращает изменённый массив.
// split/join – преобразует строку в массив и обратно.
// reduce(func, initial) – вычисляет одно значение на основе всего массива, 
// вызывая func для каждого элемента и передавая промежуточный результат 
// между вызовами.

// Дополнительно:

// Array.isArray(arr) проверяет, является ли arr массивом.
// Обратите внимание, что методы sort, reverse и splice изменяют 
// исходный массив.

// Изученных нами методов достаточно в 99% случаев, но существуют и другие.

// arr.some(fn)/arr.every(fn) проверяет массив.

// Функция fn вызывается для каждого элемента массива аналогично map. 
// Если какие-либо/все результаты вызовов являются true, то метод 
// возвращает true, иначе false.

// arr.fill(value, start, end) – заполняет массив повторяющимися value, начиная 
// с индекса start до end.

// arr.copyWithin(target, start, end) – копирует свои элементы, 
// начиная со start и заканчивая end, в собственную позицию target 
// (перезаписывает существующие).

// Полный список есть в справочнике MDN.

// На первый взгляд может показаться, что существует очень много разных 
//методов, которые довольно сложно запомнить. Но это гораздо проще, чем кажется.

// Внимательно изучите шпаргалку, представленную выше, а затем, чтобы 
// попрактиковаться, решите задачи, предложенные в данной главе. Так вы получите
// необходимый опыт в правильном использовании методов массива.

// Всякий раз, когда вам будет необходимо что-то сделать с массивом, 
// а вы не знаете, как это сделать – приходите сюда, смотрите на таблицу 
// и ищите правильный метод. Примеры помогут вам всё сделать правильно, и 
// вскоре вы быстро запомните методы без особых усилий.



//______________ЦИКЛЫ________________


// ~~~~~~~~~~~~~ FOR
const arr9 = [1,2,3,4,5];
// for (let i=0; i <arr9.length; i++) {
//   console.log(arr9[i]);
// }


// ~~~~~~~~~~~~~FOR OF  - работает только с массивами, строками и числами
// for (let value of arr9){
//   console.log(value);
// }


// ~~~~~~~~~~~~~forEach - принимает 3 параметра (индекс, значение, массив)

arr9.forEach(function(item, index, arr9) {

  // console.log(item);
  // console.log(index);

  console.log("Индекс:"+index+" Значение:"+item+" из массива = "+arr9);


});


// ____________Псевдомассивы это отображение массивов в браузере_______

// у псевдо массива есть -------proto


let object = {0: 1, 1:2, 2:3, length: 3 };
let array =[];

// Преобразуем псевдомассив в массив

for (let i=0; i < object.length; i++) {
  array.push(object[i]);
  console.log(object[i]);
}

console.log(array);  // [1, 2, 3]

